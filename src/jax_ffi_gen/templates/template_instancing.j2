{# Template for generating template parameter dispatch maps #}
    // We have template parameters, so we need to instantiate all valid templates.
    // We select a function pointer through a map with a stable, type-erased signature.
    using TTuple = std::tuple<
    {%- for p in f.template_par.values() -%}
        {{ p.type }}{{ ", " if not loop.last else "" }}
    {%- endfor -%}
    >;

    {%- if f.is_kernel %}
    using TFunc = const void*;
    {%- else %}
    using TFunc = {{ f.name }}DispatchFn;
    {%- endif %}

    static const std::map<TTuple, TFunc> instance_map = {
    {%- for i in range(f.template_values_str()|length) %}
        {%- set tval = f.template_values_str()[i] %}
        {%- set dval = f.dispatch_values_str()[i] %}
        {%- if f.is_kernel %}
        { {{ "{" ~ dval ~ "}" }}, reinterpret_cast<TFunc>(&{{ f.name }}<{{ tval }}>) }{{ "," if not loop.last else "" }}
        {%- else %}
        { {{ "{" ~ dval ~ "}" }}, &{{ f.name }}DispatchWrapper<{{ tval }}> }{{ "," if not loop.last else "" }}
        {%- endif %}
    {%- endfor %}
    };

    const TTuple key = TTuple(
    {%- for p in f.template_par.values() -%}
        {{ p.name }}{{ ", " if not loop.last else "" }}
    {%- endfor -%}
    );

    const auto it = instance_map.find(key);
    if (it == instance_map.end()) {
        return ffi::Error::Internal(
            "\nUnsupported template parameter combination for (
                {%- for k in f.template_par.keys() -%}{{k}}{{ ", " if not loop.last else "" }}{%- endfor -%})"\
            " in {{f.name}}FFIHost -- Only supporting:\n"\
            "{%- for tval in f.template_values_str()-%}
            ({{ tval }}){{ ", " if not loop.last else "" }}
            {%- endfor -%}"
        );
    }
    {%- if f.is_kernel %}
    const void* instance = it->second;
    {%- else %}
    {{ f.name }}DispatchFn instance = it->second;
    {%- endif %}