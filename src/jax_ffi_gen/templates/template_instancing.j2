    // We have template parameters, so we need to instantiate all valid templates
    // For this we select a function pointer through a map
    using TTuple = std::tuple<
    {%- for p in f.template_par.values()-%}
        {{ p.type }}{{ ", " if not loop.last else "" }}
    {%- endfor %}>;
    using TFunctionType = decltype({{f.name}}<{{ f.template_values_str()[0] }}>);

    std::map<TTuple, TFunctionType*> instance_map;
    {%- for tval in f.template_values_str()%}
    instance_map[{ {{-tval-}}  }] = {{f.name}}<{{ tval }}>;
    {%- endfor %}

    auto it = instance_map.find({
    {%- for p in f.template_par.values() -%}
        {{ p.name }}{{ ", " if not loop.last else "" }}
    {%- endfor -%}
    });

    if(it == instance_map.end()) {
        return ffi::Error::Internal(
            "\nUnsupported template parameter combination for (
                {%- for k in f.template_par.keys() -%}{{k}}{{ ", " if not loop.last else "" }}{%- endfor -%})"\
            " in {{f.name}}FFIHost -- Only supporting:\n"\
            "{%- for tval in f.template_values_str()-%}
            ({{ tval }}){{ ", " if not loop.last else "" }}
            {%- endfor -%}"
        );
    }

    TFunctionType* instance = it->second;