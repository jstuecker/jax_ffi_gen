{%- set sep = joiner(",") -%}
ffi::Error {{ f.name }}FFIHost({{ sep() }}
    cudaStream_t stream
{%- for p in f.par -%}
        {%- if p.is_ptr -%}
            {%- if p.is_const -%}{{ sep() }}
    ffi::AnyBuffer {{ p.name -}}
            {%- else %}{{ sep() }}
    ffi::Result<ffi::AnyBuffer> {{ p.name -}}
            {%- endif -%}
        {%- elif not p.expression -%}{{ sep() }}
    {{ p.type }} {{ p.name -}}
        {%- endif -%}
{%- endfor -%}
{%- for p in f.template_par.values() -%}{{ sep() }}
    {{ p.type }} {{ p.name }}
{%- endfor -%}
{%- if f.is_kernel and not f.grid_size_expression -%}{{ sep() }}
    size_t grid_size
{%- endif -%}
{%- if f.is_kernel and not f.block_size_expression -%}{{ sep() }}
    size_t block_size
{%- endif %}
) {
{%- for p in f.par -%}
    {%- if not p.is_ptr and p.expression %}
    {{ p.type }} {{ p.name }} = {{ p.expression -}};
    {%- endif -%}
{%- endfor %}

{%- if f.is_kernel -%}
    {%- if f.block_size_expression%}
    dim3 blockDim({{ f.block_size_expression }});
    {%- else %}
    dim3 blockDim(block_size);
    {%- endif %}
    {%- if f.grid_size_expression %}
    dim3 gridDim({{ f.grid_size_expression }});
    {%- else %}
    dim3 gridDim(grid_size);    
    {%- endif %}
    size_t smem = {{ f.smem_size_expression or "0"}};

    {%- for p in f.par if (p.is_ptr and not p.is_const) and (p.init_zero or f.init_outputs_zero) %}
    {% if loop.index == 1 %}
    // Initialize output buffers
    {% endif -%}
    cudaMemsetAsync({{ p.name }}->untyped_data(), 0, {{ p.name }}->size_bytes(), stream);
    {%- endfor %}
    
    // Build a bundled argument list for cudaLaunchKernel
    // For pointers we need to create a pointer to the pointer
    {%- for p in f.par %}
        {%-if p.is_ptr %}
    {{p.type}}* {{p.name}}_val = {{""}}
            {%- if p.is_const -%}
            reinterpret_cast<{{p.type}}*>({{ p.name }}.untyped_data());
            {%- else -%}
            reinterpret_cast<{{p.type}}*>({{ p.name }}->untyped_data());
            {%- endif -%}
        {%- endif %}
    {%- endfor %}

    void* args[] = {
    {%- for p in f.par %}
        {%-if p.is_ptr %}
        &{{p.name}}_val
        {%- else %}
        &{{ p.name }}
        {%- endif %}
        {{- "," if not loop.last else "" }}
    {%- endfor %}
    };

    {%- if f.template_par %}
    
{% include "template_instancing.j2" %}
    
    cudaLaunchKernel((const void*)instance, gridDim, blockDim, args, smem, stream);
    {%- else %}
    cudaLaunchKernel((const void*){{f.name}}, gridDim, blockDim, args, smem, stream);
    {%- endif %}
{%- else -%}
    {%- if f.template_par %}

{% include "template_instancing.j2" %}
    {%- endif %}

    // Now call our function
    {%- set return_type  %}
    {%- if f.type != "void"%}{{ f.type }} result = {%endif-%}
    {%- endset -%}

    {%- if f.template_par %}
    {{ return_type }}instance(
    {%- else %}
    {{ return_type }}{{ f.name }}(
    {%- endif %}
        stream,
    {%- for p in f.par %}
        {%if p.is_ptr -%}
            {%- if p.is_const -%}
        reinterpret_cast<{{p.type}}*>({{ p.name }}.untyped_data())
            {%- else -%}
        reinterpret_cast<{{p.type}}*>({{ p.name }}->untyped_data())
            {%- endif -%}
        {%- else -%}
            {{ p.name }}
        {%- endif -%}
        {{- "," if not loop.last else "" }}
    {%- endfor %}
    );

    {%- if f.type == "std::string" %}
    // Check if the function returned an error string
    if (!result.empty()) {
        return ffi::Error::Internal(result);
    }
    {%- endif %}
{%- endif %}

    cudaError_t last_error = cudaGetLastError();
    if (last_error != cudaSuccess) {
        return ffi::Error::Internal(std::string("CUDA error: ") + cudaGetErrorString(last_error));
    }
    return ffi::Error::Success();
}

XLA_FFI_DEFINE_HANDLER_SYMBOL(
    {{ f.name }}FFI, {{ f.name }}FFIHost,
    ffi::Ffi::Bind()
        .Ctx<ffi::PlatformStream<cudaStream_t>>()
{%- for p in f.par %}
        {%- if p.is_ptr %}
            {%- if p.is_const %}
        .Arg<ffi::AnyBuffer>() // {{ p.name }}
            {%- else %}
        .Ret<ffi::AnyBuffer>() // {{ p.name }}
            {%- endif %}
        {%- elif not p.expression %}
        .Attr<{{p.type}}>("{{ p.name }}")
        {%- endif %}
{%- endfor %}
{%- for p in f.template_par.values() %}
        .Attr<{{p.type}}>("{{ p.name }}")
{%- endfor %}
{%- if f.is_kernel and not f.grid_size_expression %}
        .Attr<size_t>("grid_size")
{%- endif %}
{%- if f.is_kernel and not f.block_size_expression %}
        .Attr<size_t>("block_size")
{%- endif %},
    {xla::ffi::Traits::kCmdBufferCompatible}
);