{%- set sep = joiner(",") -%}
{%- macro dispatch_params() -%}
    cudaStream_t stream{% if f.par %},{% endif %}
{%- for p in f.par %}
    {%- if p.is_ptr %}
    {{ "const " if p.is_const else "" }}void* {{ p.name }}{% if not loop.last %},{% endif %}
    {%- else %}
    {{ p.type }} {{ p.name }}{% if not loop.last %},{% endif %}
    {%- endif %}
{%- endfor %}
{%- endmacro -%}

{%- macro template_params(format='values') -%}
{%- for p in f.template_par.values() -%}
{%- if format == 'decl' -%}
{{ p.type }} {{ p.name }}
{%- else -%}
{{ p.name }}
{%- endif -%}
{{ ", " if not loop.last else "" }}
{%- endfor -%}
{%- endmacro -%}



{%- macro wrapper_call_args() -%}
        stream{% if f.par %},{% endif %}
{%- for p in f.par %}
        {%- if p.is_ptr %}
        reinterpret_cast<{{ "const " if p.is_const else "" }}{{ p.type }}*>({{ p.name }}){% if not loop.last %},{% endif %}
        {%- else %}
        {{ p.name }}{% if not loop.last %},{% endif %}
        {%- endif %}
{%- endfor %}
{%- endmacro -%}

{%- macro get_ptr_data(p) -%}
{%- if p.is_const -%}
{{ p.name }}.untyped_data()
{%- else -%}
{{ p.name }}->untyped_data()
{%- endif -%}
{%- endmacro -%}

{%- macro direct_call_args() -%}
        stream{% if f.par %},{% endif %}
{%- for p in f.par %}
        {%- if p.is_ptr %}
        reinterpret_cast<{{ "const " if p.is_const else "" }}{{ p.type }}*>({{ get_ptr_data(p) }}){% if not loop.last %},{% endif %}
        {%- else %}
        {{ p.name }}{% if not loop.last %},{% endif %}
        {%- endif %}
{%- endfor %}
{%- endmacro -%}

{%- macro instance_call_args() -%}
        stream{% if f.par %},{% endif %}
{%- for p in f.par %}
        {%- if p.is_ptr %}
        {{ get_ptr_data(p) }}{% if not loop.last %},{% endif %}
        {%- else %}
        {{ p.name }}{% if not loop.last %},{% endif %}
        {%- endif %}
{%- endfor %}
{%- endmacro -%}

{% if not f.is_kernel and f.template_par %}
using {{ f.name }}DispatchFn = {{ f.type }} (*) (
{{- dispatch_params() }}
);
template<{{- template_params('decl') -}}>
static {{ f.type }} {{ f.name }}DispatchWrapper(
{{- dispatch_params() }}
) {
    {%- if f.type != "void" %}
    return {{ f.name }}<{{- template_params('values') -}}> (
{{- wrapper_call_args() }}
    );
    {%- else %}
    {{ f.name }}<{{- template_params('values') -}}> (
{{- wrapper_call_args() }}
    );
    {%- endif -%}
    {%- if f.type == "void" %}
    return;
    {%- endif %}
}

{% endif %}
ffi::Error {{ f.name }}FFIHost({{ sep() }}
    cudaStream_t stream
{%- for p in f.par -%}
        {%- if p.is_ptr -%}
            {%- if p.is_const -%}{{ sep() }}
    ffi::AnyBuffer {{ p.name -}}
            {%- else %}{{ sep() }}
    ffi::Result<ffi::AnyBuffer> {{ p.name -}}
            {%- endif -%}
        {%- elif not p.expression -%}{{ sep() }}
    {{ p.type }} {{ p.name -}}
        {%- endif -%}
{%- endfor -%}
{%- for p in f.template_par.values() -%}
    {%- if not p.expression and not p.dtype_from_buffer -%}{{ sep() }}
    {{ p.ctype() }} {{ p.name }}
    {%- endif -%}
{%- endfor -%}
{%- if f.is_kernel and not f.grid_size_expression -%}{{ sep() }}
    size_t grid_size
{%- endif -%}
{%- if f.is_kernel and not f.block_size_expression -%}{{ sep() }}
    size_t block_size
{%- endif %}
) {
{%- for p in f.par -%}
    {%- if not p.is_ptr and p.expression %}
    {{ p.type }} {{ p.name }} = {{ p.expression -}};
    {%- endif -%}
{%- endfor %}
{%- for p in f.template_par.values() -%}
    {%- if p.expression %}
    {{ p.ctype() }} {{ p.name }} = {{ p.expression -}};
    {%- endif -%}
{%- endfor %}

{%- if f.is_kernel -%}
    {%- if f.block_size_expression%}
    dim3 blockDim({{ f.block_size_expression }});
    {%- else %}
    dim3 blockDim(block_size);
    {%- endif %}
    {%- if f.grid_size_expression %}
    dim3 gridDim({{ f.grid_size_expression }});
    {%- else %}
    dim3 gridDim(grid_size);    
    {%- endif %}
    size_t smem = {{ f.smem_size_expression or "0"}};

    {%- for p in f.par if (p.is_ptr and not p.is_const) and (p.init_zero or f.init_outputs_zero) %}
    {% if loop.index == 1 %}
    // Initialize output buffers
    {% endif -%}
    cudaMemsetAsync({{ p.name }}->untyped_data(), 0, {{ p.name }}->size_bytes(), stream);
    {%- endfor %}
    
    // Build a bundled argument list for cudaLaunchKernel
    {%- for p in f.par if p.is_ptr %}
    void* {{ p.name }}_arg = {{ get_ptr_data(p) }};
    {%- endfor %}
    void* args[] = {
    {%- for p in f.par %}
        {%- if p.is_ptr %}
        &{{ p.name }}_arg{{ "," if not loop.last else "" }}
        {%- else %}
        &{{ p.name }}{{ "," if not loop.last else "" }}
        {%- endif %}
    {%- endfor %}
    };

    {%- if f.template_par %}
    
{% include "template_instancing.j2" %}
    {%- else %}
    const void* instance = (const void*){{f.name}};
    {%- endif %}

    cudaLaunchKernel(
        instance,
        gridDim,
        blockDim,
        args,
        smem,
        stream
    );
{%- else -%}
    {%- if f.template_par %}

{% include "template_instancing.j2" %}
    {%- endif %}

    // Now call our function
    {%- set return_type  %}
    {%- if f.type != "void"%}{{ f.type }} result = {%endif-%}
    {%- endset -%}

    {%- if f.template_par %}
    {{ return_type }}instance(
{{- instance_call_args() }}
    );
    {%- else %}
    {{ return_type }}{{ f.name }}(
{{- direct_call_args() }}
    );
    {%- endif %}

    {%- if f.type == "std::string" %}
    // Check if the function returned an error string
    if (!result.empty()) {
        return ffi::Error::Internal(result);
    }
    {%- elif f.type == "ffi::Error" %}
    // Check if the function returned an error
    if (!result.success()) {
        return result;
    }
    {%- endif %}
{%- endif %}

    cudaError_t last_error = cudaGetLastError();
    if (last_error != cudaSuccess) {
        return ffi::Error::Internal(std::string("CUDA error: ") + cudaGetErrorString(last_error));
    }
    return ffi::Error::Success();
}

XLA_FFI_DEFINE_HANDLER_SYMBOL(
    {{ f.name }}FFI, {{ f.name }}FFIHost,
    ffi::Ffi::Bind()
        .Ctx<ffi::PlatformStream<cudaStream_t>>()
{%- for p in f.par %}
        {%- if p.is_ptr %}
            {%- if p.is_const %}
        .Arg<ffi::AnyBuffer>() // {{ p.name }}
            {%- else %}
        .Ret<ffi::AnyBuffer>() // {{ p.name }}
            {%- endif %}
        {%- elif not p.expression %}
        .Attr<{{p.type}}>("{{ p.name }}")
        {%- endif %}
{%- endfor %}
{%- for p in f.template_par.values() %}
    {%- if not p.expression and not p.dtype_from_buffer %}
        .Attr<{{p.ctype()}}>("{{ p.name }}")
    {%- endif %}
{%- endfor %}
{%- if f.is_kernel and not f.grid_size_expression %}
        .Attr<size_t>("grid_size")
{%- endif %}
{%- if f.is_kernel and not f.block_size_expression %}
        .Attr<size_t>("block_size")
{%- endif %},
    {xla::ffi::Traits::kCmdBufferCompatible}
);