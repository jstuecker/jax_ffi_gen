// This file was automatically generated
// You can modify it, but I recommend automatically regenerating this code whenever you adapt 
// one of the kernels. The FFI Bindings are very tedious in jax and they involve a lot of 
// boilerplate code that is easy to mess up.

#include <map>
#include <tuple>
#include "nanobind/nanobind.h"
#include "xla/ffi/api/ffi.h"

// A wrapper to encapsulate an FFI call
template <typename T>
nanobind::capsule EncapsulateFfiCall(T *fn) {
    static_assert(std::is_invocable_r_v<XLA_FFI_Error *, T, XLA_FFI_CallFrame *>,
                  "Encapsulated function must be and XLA FFI handler");
    return nanobind::capsule(reinterpret_cast<void *>(fn));
}

{%- for inc in includes %}
#include "{{ inc }}"
{%- endfor %}

namespace nb = nanobind;
namespace ffi = xla::ffi;

using DT = ffi::DataType;

{%- for f in functions %}

/* ---------------------------------------------------------------------------------------------- */
/*                             FFI call to CUDA kernel: {{ "{:41}".format(f.name) }} */
/* ---------------------------------------------------------------------------------------------- */

{% include "template_ffi_call.j2" %}

{%- endfor %}

/* ---------------------------------------------------------------------------------------------- */
/*                               Module declaration through nanobind                              */
/* ---------------------------------------------------------------------------------------------- */

NB_MODULE({{ module_name }}, m) {
{%- for f in functions %}
    m.def("{{ f.name }}", []() { return EncapsulateFfiCall(&{{ f.name }}FFI); });
{%- endfor %}
}